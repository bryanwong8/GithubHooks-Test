<!--Title={Binary Search Tree Delete}-->

# BSTDelete()

The last fundamental function that allows us to interact with BSTs is `BSTDelete`, which will allow us to remove unwanted nodes from our tree. `BSTDelete` is arguably the most complicated of the BST functions we have learned so far because we have to fix the tree once we remove a node.

##### Deleting a BST Node:

When deleting a BST node, there are **two main cases**:

* **Leaf/1 Child Case:** The easier of the two cases is when the node we want to delete is a leaf in the BST or a node with only one child. Since a leaf does not have any children, deleting it from a BST leaves us with a proper BST, meaning we do not have to change the structure of the tree and can simply remove the node. Also, if a node we want to delete only has one child, we can just delete that node and place its child where it used to be. Here is an example of case 1:

  <img src="https://i0.wp.com/www.techiedelight.com/wp-content/uploads/Deletion-in-BST-Case-1.png?zoom=2.625&resize=368%2C142&ssl=1"> 

* **Internal Node Case**: The more challenging case occurs when you want to delete an internal node in the BST. If you simply deleted the node, you would lose the children. Therefore, when an internal node is deleted, it must be replaced with the maximum node of the deleted node's left subtree or minimum node of the deleted node's right subtree (your code implementation will determine the preference between these two options) in order to still follow the rules of a BST. Here is an illustration that should help your understanding:

  <img src="data:image/png;base64,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" width="350">

#### BSTDelete()

Due to the various cases when deleting a BST node, the `BSTDelete` function is a little more complex than `BSTSearch` and `BSTInsert`. However, don't be intimidated by the code; make certain you understand the process of deleting a node, because the code simply follows that logic. Let's take a look:

```Python
def smallestNode(curNode):
    inspectedNode = curNode
    while(inspectedNode.left is not None):
        inspectedNode = inspectedNode.left  #Go left as far as possible
    return inspectedNode

def BSTDelete(curNode, key):
    if curNode is None:
        return curNode
    if (key < curNode.key):
        curNode.left = BSTDelete(curNode.left, key)
    elif (key > curNode.key):
        curNode.right = BSTDelete(curNode.right, key)
    else:  #found node to be deleted
        if curNode.left is None:  #Case 1
            tempNode = curNode.right
            curNode = None  #Delete node
            return tempNode
        elif curNode.right is None:  #Case 1
            tempNode = curNode.left
            curNode = None  #Delete node
            return tempNode
        	
        #Internal Node Case:
        tempNode = smallestNode(curNode.right) #find smallest key node of right subtree
        curNode.key = tempNode.key
        curNode.right = BSTDelete(curNode.right, tempNode.key)
        
            
```

The first half of `BSTDelete` is simply finding the node that is desired to be deleted. Once found, it will enter the else statement and begin the process of being deleted. The code becomes a bit confusing when we get to the **Internal Node Case**. As you can see, it takes advantage of a function `smallestNode` that simply goes left until it finds null, which will return the smallest key in that tree. The **Internal Node Case** calls smallestNode on the right child of the node we want to delete, meaning we are going to be replacing the node we want to delete with the smallest key node of its right subtree. We then simply swap their keys and call `BSTDelete` on the node now containing the key of the node we orginally wanted to delete (this node will eventually be deleted once it gets to a **Case 1** scenario). 

Although `BSTDelete` seems complicated initially, if you read through it slowly, you will realize that it simply follows the logic of either the **Leaf/1 Child Case** or the **Internal Node Case**. I recommend rereading the two cases if you're having trouble understanding the `BSTDelete` code.

The Big O time complexity of `delete()` is O(h), h being the height of the binary search tree. O(h) is O(nlogn), since the height of a binary search is nlog(n). So, the 'taller' the tree, the more time it takes to delete a value. The node that takes the longest to delete would be the root of the tree, because it takes O(h) to replace the root with the smallest node. 