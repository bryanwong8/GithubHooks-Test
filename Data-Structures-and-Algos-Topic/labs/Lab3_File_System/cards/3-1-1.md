<!---title{print_ordered_file_structure() Function Part 1 Explained}--->

<!--badges={Python:18,Algorithms:18}-->

<!--concepts={directedGraphs, introToGraphs, useOfGraphs, Depth First Search (DFS), Stack Manipulation}-->

# steps

## 3-1-1 Step 1

### name

```
**Step 1: Understand DFS**
```

### md_content

```
`DFS` is an algorithm which traverses a graph (directed or undirected) through the use of a `stack`. We start with a given start node (in this case the root), mark it as visited, and push its unvisited neighbors to the `stack`. We then pop the top node off of the `stack`, mark it as visited, and repeat this process until all the nodes have been visited. 

Hopefully that rings a bell. Its important to have a fundamental understanding of `DFS` to complete this part of the lab. As always, if needed, you can refer back to the activities which discuss `DFS` in depth (no pun intended!)

Let's get to the specifics of this problem now. We begin with the first 4 steps of the initial set up of the DFS algorithm for this problem.
```

## 3-1-1 Step 2

### name

```
**Step 2: Create visited defaultdict(bool)**
```

### md_content

```
You need to create a `visited` `defaultdict(bool)`. We have to use a `defaultdict` because we need to index our `visited` by the string that identifies a given node (i.e `"011"`). 
```

### code_snippet

```python
        visited = defaultdict(bool)
```

## 3-1-1 Step 3

### name

```
**Step 3: Creating the `stack`**
```

### md_content

```
A `stack` must be created since it will hold which nodes we need to visit next. Here it will enable us to print out our "folders" in the correct relative order: 
```

### code_snippet

```python
		stack = []
```

### md_content

```
Why does a `stack` work in doing this? Well, this is because this problem wants us to list the folders in an order such that we go as "far" down the folder hierarchy as possible **before** going back up (once we can't go any further down). That is, we wish to print `0` , then its first child `01` , then its children `011`, `012`, `013` **before** we print `0`'s second child, `02` (refer to diagram below).  
```

### image

<img src="../Images/411_FileSystemTreeStack.jpg" style="zoom:24%;" />

### md_content

```
Notice how we are going as far down the tree as possible by popping from the **top** of `stack`. The `stack` allows us to do this as we can add all the unprinted, neighboring folders of the folder we just printed, pop the **top** of the `stack` and print that folder, and repeat this process until all the folders are printed.

Now back to the code.    
```

## 3-1-1 Step 4

### name

```
**Step 4: Push values into `stack` using `start` to represent the first item**
```

### md_content

```
Since we want to start with `start`, we need to push it onto our `stack`
```

### code_snippet

```python
		stack.append(start)
```

## 3-1-1 Step 5

### name

```
**Step 5: Signify that each item that was added into the `stack` is in the `stack` (i.e. mark it as `True`)**
```

### md_content

```
Since we are pushing `start` onto our `stack`, that means we will have already visited it, so we need to mark it as such:
```

### code_snippet

```python
		visited[start] = True
```

### md_content

```
Given that our start node has been pushed on the `stack` and marked as visited, it is time to start the DFS traversal. Try to think about how you can implement DFS in the context of this lab.
```

